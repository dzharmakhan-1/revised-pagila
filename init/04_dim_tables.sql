-- =========================================================
-- 04_dim_tables.sql
-- Creates + populates dimension tables (with surrogate keys)
-- Includes SCD2 (Type 2) for Geography + Store
-- =========================================================

SET search_path TO analytics, public;

-- -----------------------------
-- DIM: DATE
-- -----------------------------
DROP TABLE IF EXISTS analytics.dim_date CASCADE;

CREATE TABLE analytics.dim_date (
    date_id     DATE PRIMARY KEY,
    year        INT NOT NULL,
    quarter     INT NOT NULL,
    month       INT NOT NULL,
    month_name  TEXT NOT NULL,
    week        INT NOT NULL,
    day         INT NOT NULL,
    day_name    TEXT NOT NULL,
    is_weekend  BOOLEAN NOT NULL
);

WITH bounds AS (
  SELECT
    MIN(payment_date)::date AS min_d,
    MAX(payment_date)::date AS max_d
  FROM public.payment
)
INSERT INTO analytics.dim_date
SELECT
    d::date AS date_id,
    EXTRACT(YEAR FROM d)::INT,
    EXTRACT(QUARTER FROM d)::INT,
    EXTRACT(MONTH FROM d)::INT,
    TRIM(TO_CHAR(d, 'Month')) AS month_name,
    EXTRACT(WEEK FROM d)::INT,
    EXTRACT(DAY FROM d)::INT,
    TRIM(TO_CHAR(d, 'Day')) AS day_name,
    EXTRACT(ISODOW FROM d) IN (6,7) AS is_weekend
FROM bounds b,
     generate_series(b.min_d, b.max_d, interval '1 day') d;

-- -----------------------------
-- DIM: CATEGORY (Type 1)
-- -----------------------------
DROP TABLE IF EXISTS analytics.dim_category CASCADE;

CREATE TABLE analytics.dim_category (
    category_sk   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    category_id   INT NOT NULL,
    category_name TEXT NOT NULL,
    last_update   TIMESTAMP,
    CONSTRAINT uq_dim_category_category_id UNIQUE (category_id)
);

INSERT INTO analytics.dim_category (category_id, category_name, last_update)
SELECT c.category_id, c.name, c.last_update
FROM public.category c;

CREATE INDEX idx_dim_category_category_id
ON analytics.dim_category (category_id);

-- -----------------------------
-- DIM: GEOGRAPHY (SCD2, natural key = city_id)
-- -----------------------------
DROP TABLE IF EXISTS analytics.dim_geography CASCADE;

CREATE TABLE analytics.dim_geography (
    geography_sk   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    city_id        INT NOT NULL,
    city           TEXT NOT NULL,
    country_id     INT NOT NULL,
    country        TEXT NOT NULL,

    effective_from DATE NOT NULL,
    effective_to   DATE NOT NULL DEFAULT DATE '9999-12-31',
    is_current     BOOLEAN NOT NULL DEFAULT TRUE,
    record_hash    TEXT NOT NULL
);

CREATE UNIQUE INDEX ux_dim_geography_current
    ON analytics.dim_geography (city_id)
    WHERE is_current;

CREATE INDEX ix_dim_geography_scd_range
    ON analytics.dim_geography (city_id, effective_from, effective_to);

CREATE INDEX idx_dim_geography_country_id
    ON analytics.dim_geography (country_id);

-- anchor to earliest payment date to guarantee fact date-range joins match
WITH min_pay AS (
  SELECT MIN(payment_date)::date AS min_d FROM public.payment
)
INSERT INTO analytics.dim_geography (city_id, city, country_id, country, effective_from, record_hash)
SELECT
    ci.city_id,
    ci.city,
    co.country_id,
    co.country,
    (SELECT min_d FROM min_pay) AS effective_from,
    md5(concat_ws('|', ci.city, co.country)) AS record_hash
FROM public.city ci
JOIN public.country co
  ON ci.country_id = co.country_id;

-- -----------------------------
-- DIM: STORE (SCD2, denormalized, natural key = store_id)
-- -----------------------------
DROP TABLE IF EXISTS analytics.dim_store CASCADE;

CREATE TABLE analytics.dim_store (
    store_sk         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    store_id         INT NOT NULL,
    manager_staff_id INT,
    address_id       INT NOT NULL,

    city_id          INT NOT NULL,
    city             TEXT NOT NULL,
    country_id       INT NOT NULL,
    country          TEXT NOT NULL,

    effective_from   DATE NOT NULL,
    effective_to     DATE NOT NULL DEFAULT DATE '9999-12-31',
    is_current       BOOLEAN NOT NULL DEFAULT TRUE,
    record_hash      TEXT NOT NULL
);

CREATE UNIQUE INDEX ux_dim_store_current
    ON analytics.dim_store (store_id)
    WHERE is_current;

CREATE INDEX ix_dim_store_scd_range
    ON analytics.dim_store (store_id, effective_from, effective_to);

CREATE INDEX idx_dim_store_city_id
    ON analytics.dim_store (city_id);

-- anchor effective_from same as dims (earliest payment date)
WITH min_pay AS (
  SELECT MIN(payment_date)::date AS min_d FROM public.payment
)
INSERT INTO analytics.dim_store (
  store_id, manager_staff_id, address_id,
  city_id, city, country_id, country,
  effective_from, record_hash
)
SELECT
  s.store_id,
  s.manager_staff_id,
  s.address_id,
  c.city_id,
  c.city,
  co.country_id,
  co.country,
  (SELECT min_d FROM min_pay) AS effective_from,
  md5(concat_ws('|', s.manager_staff_id, s.address_id, c.city, co.country)) AS record_hash
FROM public.store s
JOIN public.address a ON s.address_id = a.address_id
JOIN public.city c     ON a.city_id = c.city_id
JOIN public.country co ON c.country_id = co.country_id;
-- =========================================================