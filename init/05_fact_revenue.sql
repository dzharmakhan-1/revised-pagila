-- =========================================================
-- 05_fact_revenue.sql
-- Fact table using surrogate keys
-- Grain: 1 row per payment
-- =========================================================

SET search_path TO analytics, public;

DROP TABLE IF EXISTS analytics.fact_revenue CASCADE;

CREATE TABLE analytics.fact_revenue (
    revenue_id     BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    payment_id     INT NOT NULL,          -- degenerate key
    payment_ts     TIMESTAMP NOT NULL,
    date_id        DATE NOT NULL,

    category_sk    BIGINT NOT NULL,
    store_sk       BIGINT NOT NULL,
    geography_sk   BIGINT NOT NULL,

    revenue_amount NUMERIC(10,2) NOT NULL
);

-- exactly one row per payment
ALTER TABLE analytics.fact_revenue
ADD CONSTRAINT uq_fact_revenue_payment UNIQUE (payment_id);

ALTER TABLE analytics.fact_revenue
ADD CONSTRAINT fk_fact_date
FOREIGN KEY (date_id)
REFERENCES analytics.dim_date (date_id);

ALTER TABLE analytics.fact_revenue
ADD CONSTRAINT fk_fact_category
FOREIGN KEY (category_sk)
REFERENCES analytics.dim_category (category_sk);

ALTER TABLE analytics.fact_revenue
ADD CONSTRAINT fk_fact_store
FOREIGN KEY (store_sk)
REFERENCES analytics.dim_store (store_sk);

ALTER TABLE analytics.fact_revenue
ADD CONSTRAINT fk_fact_geography
FOREIGN KEY (geography_sk)
REFERENCES analytics.dim_geography (geography_sk);

INSERT INTO analytics.fact_revenue (
    payment_id,
    payment_ts,
    date_id,
    category_sk,
    store_sk,
    geography_sk,
    revenue_amount
)
SELECT
    p.payment_id,
    p.payment_date AS payment_ts,
    p.payment_date::date AS date_id,

    dc.category_sk,

    ds.store_sk,
    dg.geography_sk,

    p.amount::numeric(10,2) AS revenue_amount
FROM public.payment p
JOIN public.rental r
  ON p.rental_id = r.rental_id
JOIN public.inventory i
  ON r.inventory_id = i.inventory_id
JOIN public.film_category fc
  ON i.film_id = fc.film_id
JOIN analytics.dim_category dc
  ON dc.category_id = fc.category_id

-- store from staff on payment, match SCD range
JOIN public.staff st
  ON p.staff_id = st.staff_id
JOIN analytics.dim_store ds
  ON ds.store_id = st.store_id
 AND p.payment_date::date BETWEEN ds.effective_from AND ds.effective_to

-- geography from store's address->city, match SCD range
JOIN public.store s
  ON s.store_id = st.store_id
JOIN public.address a
  ON a.address_id = s.address_id
JOIN analytics.dim_geography dg
  ON dg.city_id = a.city_id
 AND p.payment_date::date BETWEEN dg.effective_from AND dg.effective_to

JOIN analytics.dim_date dd
  ON dd.date_id = p.payment_date::date

ON CONFLICT (payment_id) DO NOTHING;

CREATE INDEX IF NOT EXISTS idx_fact_revenue_date
    ON analytics.fact_revenue (date_id);

CREATE INDEX IF NOT EXISTS idx_fact_revenue_category
    ON analytics.fact_revenue (category_sk);

CREATE INDEX IF NOT EXISTS idx_fact_revenue_store
    ON analytics.fact_revenue (store_sk);

CREATE INDEX IF NOT EXISTS idx_fact_revenue_geography
    ON analytics.fact_revenue (geography_sk);

CREATE INDEX IF NOT EXISTS idx_fact_revenue_date_category
    ON analytics.fact_revenue (date_id, category_sk);
-- =========================================================