-- =========================================================
-- 04_dim_tables.sql
-- Creates + populates dimension tables (with surrogate keys)
-- =========================================================

SET search_path TO analytics, public;

-- -----------------------------
-- DIM: DATE (natural key is fine)
-- Build date range from actual payment dates so joins never go to 0.
-- -----------------------------
DROP TABLE IF EXISTS analytics.dim_date CASCADE;

CREATE TABLE analytics.dim_date (
    date_id     DATE PRIMARY KEY,
    year        INT NOT NULL,
    quarter     INT NOT NULL,
    month       INT NOT NULL,
    month_name  TEXT NOT NULL,
    week        INT NOT NULL,
    day         INT NOT NULL,
    day_name    TEXT NOT NULL,
    is_weekend  BOOLEAN NOT NULL
);

WITH bounds AS (
  SELECT
    MIN(payment_date)::date AS min_d,
    MAX(payment_date)::date AS max_d
  FROM public.payment
)
INSERT INTO analytics.dim_date
SELECT
    d::date AS date_id,
    EXTRACT(YEAR FROM d)::INT,
    EXTRACT(QUARTER FROM d)::INT,
    EXTRACT(MONTH FROM d)::INT,
    TRIM(TO_CHAR(d, 'Month')),
    EXTRACT(WEEK FROM d)::INT,
    EXTRACT(DAY FROM d)::INT,
    TRIM(TO_CHAR(d, 'Day')),
    EXTRACT(ISODOW FROM d) IN (6,7)
FROM bounds b,
     generate_series(b.min_d, b.max_d, interval '1 day') d;

-- -----------------------------
-- DIM: CATEGORY (surrogate key)
-- -----------------------------
DROP TABLE IF EXISTS analytics.dim_category CASCADE;

CREATE TABLE analytics.dim_category (
    category_sk   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    category_id   INT NOT NULL,
    category_name TEXT NOT NULL,
    last_update   TIMESTAMP,

    CONSTRAINT uq_dim_category_category_id UNIQUE (category_id)
);

INSERT INTO analytics.dim_category (category_id, category_name, last_update)
SELECT
    c.category_id,
    c.name,
    c.last_update
FROM public.category c;

CREATE INDEX idx_dim_category_category_id
ON analytics.dim_category (category_id);


-- -----------------------------
-- DIM: GEOGRAPHY (surrogate key, natural key = city_id)
-- -----------------------------
DROP TABLE IF EXISTS analytics.dim_geography CASCADE;

CREATE TABLE analytics.dim_geography (
    geography_sk BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    city_id      INT NOT NULL,
    city         TEXT NOT NULL,
    country_id   INT NOT NULL,
    country      TEXT NOT NULL,

    CONSTRAINT uq_dim_geography_city_id UNIQUE (city_id)
);

INSERT INTO analytics.dim_geography (city_id, city, country_id, country)
SELECT
    ci.city_id,
    ci.city,
    co.country_id,
    co.country
FROM public.city ci
JOIN public.country co
    ON ci.country_id = co.country_id;

CREATE INDEX idx_dim_geography_city_id
ON analytics.dim_geography (city_id);

CREATE INDEX idx_dim_geography_country_id
ON analytics.dim_geography (country_id);


-- -----------------------------
-- DIM: STORE (star schema version)
-- store dim carries city/country directly (denormalized)
-- -----------------------------
DROP TABLE IF EXISTS analytics.dim_store CASCADE;

CREATE TABLE analytics.dim_store (
    store_sk         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    store_id         INT NOT NULL,
    manager_staff_id INT,
    address_id       INT NOT NULL,

    -- denormalized geography attributes for STAR schema
    city_id          INT NOT NULL,
    city             TEXT NOT NULL,
    country_id       INT NOT NULL,
    country          TEXT NOT NULL,

    CONSTRAINT uq_dim_store_store_id UNIQUE (store_id)
);

INSERT INTO analytics.dim_store (
    store_id, manager_staff_id, address_id,
    city_id, city, country_id, country
)
SELECT
    s.store_id,
    s.manager_staff_id,
    s.address_id,
    g.city_id,
    g.city,
    g.country_id,
    g.country
FROM public.store s
JOIN public.address a
    ON s.address_id = a.address_id
JOIN analytics.dim_geography g
    ON a.city_id = g.city_id;

CREATE INDEX idx_dim_store_store_id
    ON analytics.dim_store (store_id);

CREATE INDEX idx_dim_store_city_id
    ON analytics.dim_store (city_id);

CREATE INDEX idx_dim_store_country_id
    ON analytics.dim_store (country_id);
